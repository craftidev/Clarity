### High-Level Architecture Overview

1.  **Rust Chess Engine**

    *   **Core Engine**: Implements the chess game rules, move generation, and basic board evaluation.
    *   **Evaluation Interface**: A module that interacts with pre-trained machine learning models to receive advanced position evaluations. This could involve direct calls to Python scripts for offline models or REST API calls to a Python-based service.
    *   **UCI Protocol Support**: Engine compatible with other chess GUIs.

2.  **Flutter GUI**

    *   **Dashboard**: The main interface where users interact with the chess board, view moves, and receive evaluations.
    *   **Analysis Panel**: Displays detailed insights into the current position, using human-readable explanations generated by the Engine.
    *   **Settings/Preferences**: Allows users to configure the engine's behavior, select difficulty levels, or choose between different modes of analysis.

3.  **Python Machine Learning**

    *   **Model Training**: Scripts and notebooks for training machine learning models on chess positions, using datasets of games and annotations.
    *   **Model Serving**: Once trained, the models need to be accessible by the Rust engine. This could be through saved model files loaded by Rust, or a web service that the Rust engine queries for real-time analysis.
    *   **Evaluation Library**: A collection of functions and tools that take chess positions as input and output evaluations, insights, and recommendations, possibly with explanations for moves.

### Integration Points

*   **Rust to Python Communication**: If the Rust engine needs real-time analysis from Python-trained models, consider using a REST API for communication. Alternatively, for batch processing or offline use, the Rust engine could directly load and apply model outputs (e.g., through ONNX, TensorFlow for Rust, or similar frameworks).

*   **Flutter to Rust Communication**: The Flutter GUI communicates with the Rust engine to display the game and receive updates. Using. Using Flutter Rust Bridge project.

*   **User Actions**: User inputs from the Flutter GUI (e.g., moving pieces, selecting analysis options) are sent to the Rust engine, which processes the game state and requests ML-based evaluations as needed.

### Flutter arch
```tree
/lib/
  /themes/
    - app_colors.dart
  /settings/
    - settings_controller.dart
    - settings_view.dart
  /models/
    - game_model.dart
  /services/
    - game_service.dart
  /providers/ (if using Provider for state management)
    - chessboard_provider.dart
  /views/
    - home_view.dart
    - settings_view.dart
  /widgets/
    - chessboard.dart
    - custom_button.dart
    - custom_dialog.dart
  main.dart
```

### Assets
[Lichess staunton pieces](https://github.com/lichess-org/lila/tree/master/public/piece/staunty)
